# ПОДХОДЫ К РАЗРАБОТКЕ МИКРОСЕРВИСОВ

## Задача 1: Обеспечить разработку

### Условие

Предложите решение для обеспечения процесса разработки: хранение исходного кода, непрерывная интеграция и непрерывная поставка. 
Решение может состоять из одного или нескольких программных продуктов и должно описывать способы и принципы их взаимодействия.

Решение должно соответствовать следующим требованиям:
- облачная система;
- система контроля версий Git;
- репозиторий на каждый сервис;
- запуск сборки по событию из системы контроля версий;
- запуск сборки по кнопке с указанием параметров;
- возможность привязать настройки к каждой сборке;
- возможность создания шаблонов для различных конфигураций сборок;
- возможность безопасного хранения секретных данных (пароли, ключи доступа);
- несколько конфигураций для сборки из одного репозитория;
- кастомные шаги при сборке;
- собственные докер-образы для сборки проектов;
- возможность развернуть агентов сборки на собственных серверах;
- возможность параллельного запуска нескольких сборок;
- возможность параллельного запуска тестов.

Обоснуйте свой выбор.

### Ответ

Система разрабатывается для крупной компании, поэтому необходимо настроить свою изолированную среду для хранения исходных кодов и т.д., 
репозитории Github не подойдут. Наиболее популярные решения - использовать локальный `Gitlab` и систему управления артефактами `Jenkins`.

С точки зрения решения из "коробки" Gitlab наиболее предпочтиелен если небходимо быстро реализовать заданные требования 
с имеющимся модулем автоматизации сборок и поставок `Gitlab CI/CD`:
- _Запуск сборки по событию из системы контроля версий_: триггеры на основе push, merge request и других событий.
- _Запуск сборки по кнопке с указанием параметров_: возможность ручного запуска пайплайнов с передачей переменных.
- _Привязка настроек к каждой сборке_: использование `.gitlab-ci.yml` для определения настроек каждой сборки.
- _Создание шаблонов для различных конфигураций сборок_: использование YAML-шаблонов и включений для переиспользования конфигураций.
- _Безопасное хранение секретных данных_: GitLab CI/CD поддерживает переменные окружения с защитой секретов.
- _Несколько конфигураций для сборки из одного репозитория_: определение различных пайплайнов и окружений внутри одного репозитория.
- _Настраиваемые шаги сборки_: возможность определения пользовательских скриптов и шагов в пайплайне.
- _Собственные докер-образы для сборки проектов_: использование Docker images в качестве runners или в качестве сред для выполнения шагов.
- _Развертывание агентов сборки на собственных серверах_: настройка GitLab Runners на собственных инфраструктурах для выполнения сборок.
- _Параллельный запуск нескольких сборок и тестов_: GitLab CI/CD поддерживает параллельные джобы и динамические пайплайны.
- _Container registry_ - реестр для образов (images) Docker.
- _Сканирование уязвимостей_: сканирование уязвимостей контейнеров возможно через GitLab Secure, но требует дополнительной настройки.

Если для работы с контейнерами понадобится более широкий спектр задач, то следует обратить внимание на `Harbor`:
- встроенное сканирование уязвимостей с использованием инструментов (Trivy, Clair и др.);
- возможность настройки политики предотвращения загрузки уязвимых образов;
- более гибкое управление сертификатами и политиками безопасности.






## Задача 2: Логи

### Условие

Предложите решение для обеспечения сбора и анализа логов сервисов в микросервисной архитектуре.
Решение может состоять из одного или нескольких программных продуктов и должно описывать способы и принципы их взаимодействия.

Решение должно соответствовать следующим требованиям:
- сбор логов в центральное хранилище со всех хостов, обслуживающих систему;
- минимальные требования к приложениям, сбор логов из stdout;
- гарантированная доставка логов до центрального хранилища;
- обеспечение поиска и фильтрации по записям логов;
- обеспечение пользовательского интерфейса с возможностью предоставления доступа разработчикам для поиска по записям логов;
- возможность дать ссылку на сохранённый поиск по записям логов.

Обоснуйте свой выбор.

### Ответ

Для сбора и анализа логов в микросервисной архитектуре рекомендуется использовать стек `ELK` (Elasticsearch, Logstash, Kibana, Beats) 
или его альтернативу с открытой лицензией `OpenStack`. Оба решения соответствуют требованиям, включая сбор логов, их фильтрацию, поиск, 
предоставление интерфейса для пользователей.

Лицензионные ограничения Elasticsearch с версии 7.11 имеет ограниченную лицензию (SSPL), 
что сказывается на деятельности облачных провайдеров, но никак не хатрагивает деятельность обычных пользователей.

__Рекомендуемое решение:__ ElastikSearch + Logstash + Kibana + Fluent Bit 



## Задача 3: Мониторинг

### Условие

Предложите решение для обеспечения сбора и анализа состояния хостов и сервисов в микросервисной архитектуре.
Решение может состоять из одного или нескольких программных продуктов и должно описывать способы и принципы их взаимодействия.

Решение должно соответствовать следующим требованиям:
- сбор метрик со всех хостов, обслуживающих систему;
- сбор метрик состояния ресурсов хостов: CPU, RAM, HDD, Network;
- сбор метрик потребляемых ресурсов для каждого сервиса: CPU, RAM, HDD, Network;
- сбор метрик, специфичных для каждого сервиса;
- пользовательский интерфейс с возможностью делать запросы и агрегировать информацию;
- пользовательский интерфейс с возможностью настраивать различные панели для отслеживания состояния системы.

Обоснуйте свой выбор.

### Ответ

Для обеспечения сбора и анализа состояния хостов и сервисов в микросервисной архитектуре рекомендуется использовать стек `Prometheus + Grafana`. Это проверенное решение, которое удовлетворяет всем заявленным требованиям и обладает высокой гибкостью и масштабируемостью.

__Рекомендуемое решение:__ Prometheus + Grafana

_Возможности и преимущества:_

1. Сбор метрик:
   - `Prometheus`: Устанавливается в облаке для сбора метрик со всех хостов и сервисов через HTTP.
   - `Node Exporter`: Устанавливается на каждом хосте для сбора метрик CPU, RAM, HDD, Network.
   - _Специфичные экспортеры_: Используются для сбора метрик, специфичных для каждого микросервиса (например, JVM Exporter для Java приложений).

2. Хранение и обработка метрик:
   - `Prometheus`: Сохраняет временные ряды метрик и обеспечивает высокую производительность при запросах.

3. Визуализация и пользовательский интерфейс:
   - `Grafana`: Подключается к Prometheus для создания настраиваемых дашбордов, позволяющих агрегировать и визуализировать информацию.
   - _Настраиваемые панели_: Пользователи могут создавать различные панели для отслеживания состояния системы в реальном времени.

4. Функциональные возможности:
   - _Сбор метрик состояния ресурсов хостов и потребляемых ресурсов сервисами:_ Prometheus в сочетании с Node Exporter и сервисными экспортерами обеспечивает полный охват метрик.
   - _Специфичные метрики для каждого сервиса:_ Гибкость Prometheus позволяет добавлять новые экспортеры по мере необходимости.
   - _Запросы и агрегирование информации:_ PromQL в Prometheus предоставляет мощные возможности для запроса и агрегации метрик.
   - _Пользовательский интерфейс:_ Grafana предоставляет удобный и интуитивно понятный интерфейс для настройки и просмотра дашбордов.

__Обоснование выбора:__
- Prometheus легко масштабируется горизонтально;
- Grafana может подключаться к нескольким источникам данных и поддерживать высокую доступность;
- простота и удобство использования;
- интуитивно понятный интерфейс Grafana для создания и настройки панелей;
- минимальные требования к приложениям;
- сбор метрик из stdout или через экспортеры без необходимости изменения кода приложений;
- большое сообщество и множество документации и best practicies.
  
Prometheus и Grafana в настоящий момент стали практически стандартом для мониторинга и визуализации метрик в современных микросервисных архитектурах. 
Prometheus обеспечивает надежный и масштабируемый сбор метрик, а Grafana предоставляет мощные инструменты для создания настраиваемых панелей и визуализаций. 
Вместе они удовлетворяют все заявленные требования по сбору, анализу и отображению состояния системы.



## Задача 4: Логи * (необязательная)

### Условие

Продолжить работу по задаче API Gateway: сервисы, используемые в задаче, пишут логи в stdout.

Добавить в систему сервисы для сбора логов Vector + ElasticSearch + Kibana со всех сервисов, обеспечивающих работу API.

__Результат выполнения:__
docker compose файл, запустив который можно перейти по адресу http://localhost:8081, по которому доступна Kibana. Логин в Kibana должен быть admin, пароль qwerty123456.

### Ответ

_Позже добавлю описание..._


## Задача 5: Мониторинг * (необязательная)

### Условие

Продолжить работу по задаче API Gateway: сервисы, используемые в задаче, предоставляют набор метрик в формате prometheus:

сервис security по адресу /metrics,
сервис uploader по адресу /metrics,
сервис storage (minio) по адресу /minio/v2/metrics/cluster.
Добавить в систему сервисы для сбора метрик (Prometheus и Grafana) со всех сервисов, обеспечивающих работу API. Построить в Graphana dashboard, показывающий распределение запросов по сервисам.

__Результат выполнения:__
docker compose файл, запустив который можно перейти по адресу http://localhost:8081, по которому доступна Grafana с настроенным Dashboard. Логин в Grafana должен быть admin, пароль qwerty123456.

### Ответ

_Позже добавлю описание..._







# Задание
[https://github.com/netology-code/micros-homeworks/blob/main/11-microservices-03-approaches.md](https://github.com/netology-code/micros-homeworks/blob/main/11-microservices-03-approaches.md)
